
// create new empty array
bind new_array "stack.push(Value::Arr(vec![]));"
bind filled_array "let a = get_float(stack.pop().unwrap()) as usize; let b = stack.pop().unwrap(); stack.push(Value::Arr(vec![b; a]));"

// push to back of the array
bind push "/* push to array */
let a = stack.pop().unwrap(); let b = get_array(stack.pop().unwrap());
b.push(a); stack.push(Value::Arr(b));"

// pop last value from array
bind pop "// pop array
let mut a = get_array(stack.pop().unwrap());
let b = a.pop().unwrap(); stack.push(Value::Arr(a)); stack.push(b);"

// reverse the array
bind reverse "// reverse array
let mut a = get_array(stack.pop().unwrap());
a.reverse(); stack.push(Value::Arr(a));"

// push n values to the array
bind pushn "/* pushn */
let n = stack.pop().unwrap(); let mut a = get_array(stack.pop().unwrap());
for i in &stack[stack.len() - get_float(n) as usize ..] {a.push(i.clone());}
stack.push(Value::Arr(a));"

// get array item by index
bind arrget r#"/* arrget */ let a = get_float(stack.pop().unwrap()) as usize; let b = get_array(stack.last().unwrap());
assert!(a < b.len(), "ERROR in `arrget`: cannot get item that out of the array length.");
stack.push(b[a].clone());"#


bind arr_at r#"/* arr_at */ let a = get_float(stack.pop().unwrap()) as isize; let b = get_array(stack.pop().unwrap());
if a >= b.len() as isize || a < 0 { stack.push(Value::Undefined); }
else { stack.push(b[a as usize].clone()); }"#

// set array item by index
bind arrset r#"/* arrset */ let c = stack.pop().unwrap(); let a = get_float(stack.pop().unwrap()) as usize; let b = stack.pop().unwrap();
if let Value::Arr(mut arr) = b {
    assert!(a < arr.len(), "ERROR in `arrset`: cannot set item that out of the array length.");
    arr[a] = c;
    stack.push(Value::Arr(arr));
}"#

// push content of array to the stack
bind arrunwrap "/* unwrap array */ let a = stack.pop().unwrap(); if let Value::Arr(mut arr) = a {
    stack.append(&mut arr);
}"

// slices array
bind arrslice r#"/* arrslice */ let mut c = get_float(stack.pop().unwrap()).abs() as usize; let mut b = get_float(stack.pop().unwrap()).abs() as usize; let a = stack.pop().unwrap(); if let Value::Arr(mut arr) = a {
    if c < 0 { c = arr.len() - c; }
    if b < 0 { b = arr.len() - b; }
    stack.push(Value::Arr(arr[b .. c].to_vec()));
}"#

// append content of one array to another
bind append r#"/* append */ let Value::Arr(mut b) = stack.pop().unwrap() else { todo!() }; if let Value::Arr(mut a) = stack.pop().unwrap() {
    a.append(&mut b);
    stack.push(Value::Arr(a));
}"#

// pushes array filled with the range of numbers
bind range r#"/* range */ {let a = get_float(stack.pop().unwrap()) as usize; let b = get_float(stack.pop().unwrap()) as usize;
let mut c = vec![];
for i in b..a {c.push(Value::Real(i as f64))}
stack.push(Value::Arr(c));
}"#

// length of array. also works for strings
bind len "/* len */ let a = stack.pop().unwrap(); stack.push(Value::Real(get_float(a)));"